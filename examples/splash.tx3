using plutus_addresses.{Credential};

party User;
party Batcher;
party Pool;
party Swap;
party Deposit;
party Redeem;

policy PoolValidatorRefScript = { 
    script_hash: "5dd6feba9bb5b3bfe0fc23da8519fed7ba8bc53bd838b7dec7c4226a", 
    outref: OutputReference { 
        tx_hash: "dd6feba9bb5b3bfe0fc23da8519fed7ba8bc53bd838b7dec7c4226a", 
        index: 0 
    }
};

policy SwapValidatorRefScript = { 
    script_hash: "5dd6feba9bb5b3bfe0fc23da8519fed7ba8bc53bd838b7dec7c4226a", 
    outref: OutputReference { 
        tx_hash: "dd6feba9bb5b3bfe0fc23da8519fed7ba8bc53bd838b7dec7c4226a", 
        index: 0 
    }
};

// Support aliasing for readability
// 1. Maybe we can add `alias` keyword to the language to make them more readable
// but `type` should work as well, the same way as Aiken 
// e.g. `alias Lovelace = Int`
// 2. We can even add common aliases like `PolicyId`, `AssetName`, `Lovelace` to the language itself
type PolicyId = Bytes;
type AssetName = Bytes;
type Lovelace = Int;
type PosixTime = Int;

// Common types can be added to the language itself
type AssetClass {
    policy_id: PolicyId,
    asset_name: AssetName,
}

type OutputReference {
    tx_hash: Bytes,
    index: Int,
}

type PoolDatum {
    pool_nft: AssetClass,
    asset_x: AssetClass,
    asset_y: AssetClass,
    asset_lq: AssetClass,
    fee: Int,
    stake_admin_policy: AssetClass[],
    lq_bound: Bytes,
}

type SwapDatum {
    base: AssetClass,
    quote: AssetClass,
    pool_nft: AssetClass,
    fee: Int,
    ex_fee_per_token_num: Int,
    ex_fee_per_token_den: Int,
    reward_pkh: Bytes,
    stake_pkh: Option<Bytes>,
    base_amount: Int,
    min_quote_amount: Int
}

type DepositDatum {
    pool_nft: AssetClass,
    asset_x: AssetClass,
    asset_y: AssetClass,
    asset_lq: AssetClass,
    fee: Int,
    reward_pkh: Bytes,
    stake_pkh: Option<Bytes>,
    collateral_ada: Int,
}

type PoolRedeemer {
    action: Int,
    self_index: Int
}

type OrderRedeemer {
    pool_input_index: Int,
    order_input_index: Int,
    reward_output_index: Int,
    action: Int
}

// We don't have constants in the language yet, but we might want to add them
const ex_fee_per_token_den = 1_000_000_000; 

tx Swap(
    swap_order_outref: OutputReference, 
    pool_nft: AssetClass,
    quote_amount: Int,
    batcher_fee: Int
)
{    
    input swap_order_input {
        from: Swap,
        datum_is: SwapDatum,
        filter: (in) => in.output_reference == swap_order_outref,
        redeemer: OrderRedeemer {
            // We need a way to get the index of this input
            // I'm going to use some magic function for now
            pool_input_index: InputIndex(pool_input),
            order_input_index: InputIndex(swap_order_input),
            // We need a way to get the index of this output
            // I'm going to use some magic function for now
            reward_output_index: OutputIndex(reward_output),
            action: 0, // 0 = Swap, 1 = Refund
        }
    }

    input pool_input {
        from: Pool,
        datum_is: PoolDatum,
        filter: (in) => in.pool_nft == pool_nft,
        redeemer: PoolRedeemer {
            action: 2, // 2 = Swap
            // We need a way to get the index of this input
            // I'm going to use some magic function for now
            self_index: InputIndex(pool_input)
        },
    }

    // Update the pool reserves
    output {
        to: Pool,
        // Assuming this is how we access the full datum from an input
        datum: pool_input.datum,
        amount: pool_input - Asset(pool_input.asset_y, quote_amount) + Ada(swap_order_input.base_amount),
    }

    // Remaining ADA goes to the batcher
    output {
        to: Batcher,
        amount: Ada(swap_order_input) - base_amount - fees,
    }

    // We're just sending the swapped order to the user less fees
    output reward_output {
        to: User,
        amount: Asset(swap_order_input.quote, quote_amount),
    }

    // We need 2 validators for this transaction
    reference_input PoolValidatorRefScript;
    reference_input SwapValidatorRefScript;

    collateral {
        from: Batcher,
        amount: Ada(5)
    }
}